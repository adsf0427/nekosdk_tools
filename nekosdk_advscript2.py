# This is edited from file generated by kaitai-struct-compiler 

import kaitaistruct
from kaitaistruct import KaitaiStruct, KaitaiStream, BytesIO
import struct


if getattr(kaitaistruct, 'API_VERSION', (0, 9)) < (0, 9):
    raise Exception("Incompatible Kaitai Struct Python API: 0.9 or later is required, but you have %s" % (kaitaistruct.__version__))

class NekosdkAdvscript2(KaitaiStruct):
    def __init__(self, _io, _parent=None, _root=None):
        self._io = _io
        self._parent = _parent
        self._root = _root if _root else self
        self._read()

    def _read(self):
        self.magic = self._io.read_bytes(19)
        if not self.magic == b"\x4E\x45\x4B\x4F\x53\x44\x4B\x5F\x41\x44\x56\x53\x43\x52\x49\x50\x54\x32\x00":
            raise kaitaistruct.ValidationNotEqualError(b"\x4E\x45\x4B\x4F\x53\x44\x4B\x5F\x41\x44\x56\x53\x43\x52\x49\x50\x54\x32\x00", self.magic, self._io, u"/seq/0")
        self.nodes_qty = self._io.read_u4le()
        self.nodes = []
        for i in range(self.nodes_qty):
            self.nodes.append(NekosdkAdvscript2.Node(self._io, self, self._root))
            
    def write(self, of):
        of.write(self.magic)
        of.write(struct.pack('<I', len(self.nodes)))
        for node in self.nodes:
            node.write(of)            


    class Nekostr(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.len = self._io.read_u4le()
            self.value = (self._io.read_bytes(self.len)).decode(u"SJIS")

        def write(self, of, encoding):
            try:
                str_b = self.value.encode(encoding)
            except UnicodeEncodeError as e:
                print(f"Error encoding {e.object[e.start:e.end]}, {e.reason}, {e.encoding}")
                str_b = self.value.encode(encoding, errors='replace')
                # raise
            length = len(str_b)                
            # length = self.len
            of.write(struct.pack('<I', length))
            # if length > len(str_b):
            #     str_b += b'\x00' * (length - len(str_b))
            # else :
            #     str_b = str_b[:length]
            of.write(str_b)
            
    class Node(KaitaiStruct):
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.id = self._io.read_u4le()
            self.type1 = self._io.read_u4le()
            self.some_ofs = self._io.read_u4le()
            self.opcode = self._io.read_u4le()
            self.spacer1 = self._io.read_bytes(128)
            self.next_id = self._io.read_u4le()
            self.spacer2 = self._io.read_bytes(64)
            self.strs = []
            for i in range(33):
                self.strs.append(NekosdkAdvscript2.Nekostr(self._io, self, self._root))
                
        def write(self, of):
            of.write(struct.pack('<I', self.id))
            of.write(struct.pack('<I', self.type1))
            of.write(struct.pack('<I', self.some_ofs))
            of.write(struct.pack('<I', self.opcode))
            of.write(self.spacer1)
            of.write(struct.pack('<I', self.next_id))
            of.write(self.spacer2)

            for i, s in enumerate(self.strs):
                if self.opcode == 5 and i>=1 and i <= 2:
                    encoding = 'gbk'                
                else:
                    encoding = 'SJIS' 
                # print(f"Writing {i} with encoding {encoding}")
                s.write(of, encoding)



